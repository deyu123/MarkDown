# JAVA 总结

### 0. 测试编写
### 1.常见问题

```sql
-- 1. Java 静态属性和方法继承问题
1. 非静态的属性和方法：
	1). 非静态的属性：
		a.子类可以继承父类的非静态属性
		b.有相同的非静态属性时,不会重写覆盖
		c.隐藏父类的非静态属性
	2). 非静态方法
  	a. 子类可以继承父类的非静态方法
  	b. 并可重写父类的方法
2. 静态属性和方法：
	1). 静态属性
		a. 子类可以继承父类的静态属性， 并父类的静态属性被隐藏
	2). 静态方法
	  a. 子类可以继承父类的静态方法,但是不能重写和覆盖父类的静态方法
	  b. 子类使用同名的静态方法,父类的会被隐藏
3. java 子类重写父类,并没有覆盖父类的字段,只是隐藏了父类的字段
4. scala 子类同名字段会重写并覆盖父类的同名字段
	  
-- 2. scala 和 Java 的区别
1. 继承多种语言的特性,但是也没有抛弃这个平台
2. 运行在Java 虚拟机之上,可以调用java 类库
3. 支持面向对象的编程和面向函数式的编程
4. 写出向动态语言一样的简洁，实际上是静态语言

-- 3. trait 多继承的顺序
1. 有超类函数会先调用超类函数
2. 如果混入 trait, 会先调用父 trait 
3. 多个父trait, 从左到右开始执行
4. 父构造器和父trait 被构造之后，才会构造本类的构造器

-- 4. class 和 object 的区别
1. 单例对象不能传递参数,类可以
2. 对象和类名一样时，object 是伴生对象，class 是伴生类
3. 对象和类名一样时，可以访问彼此的私有属性，但是必须在同一个源文件中
4. 类只会被编译但是不会被执行，要想执行就要在object 中

-- 5. case class 和 class 的区别
1. 初始化的时候可以不用加上 new , 但是也可以加上，但是普通类必须要加
2. 默认实现了 equal 方法， hashcode 方法
3. 默认是序列化的，实现了serinclizable 接口
4. 构造函数式public 的，可以直接访问
5. 默认情况下，不能修改属性
6. 主要是支持模式匹配

-- 6. case class 与 case object 的区别
1. 类中有参, 无参
2. 有参case class , 无参 case object 


-- 7. HashMap 和 currentHashMap 的区别
1. 数组 + 链表 + 红黑树实现的，线程安全， 大量的cas(compare and swap) 就是比较和交换，是一种乐观锁
2. 整个Map 分成N 个segment , 效率提高了N 倍，默认是16
3. 为什么要是使用currentHashMap ? 
	a. HashMap 线程不安全的， 在多线程的情况下，调用函数transfer（）将索引数组转移，1->2->3 转移后3->2-1 , 多线程的情况下，1->2, 2->1 的环形链表，get 			的时候就会出现死循环
	b. currentHashMap 是如何解决的？ 由N 个segment 和HashEntry 组成，segment 是可重入锁，是锁的一个角色，HashEntry 来存储数据，如果想要修改数据，必须			要获取对应的segment

-- 8. 多线程访问共享变量解决方案
1. 加锁： 性能最低，能保证原子性，可见性，防止指令重排序
2. volatile 性能中等，保证可见性，指令重排序
3. getobjectvolatile 性能最好， 防止指令的重排序

--9. HashMap 底层实现
底层结构：jdk7:数组+链表 jdk8：数组+链表+红黑树

HashMap中维护了Node类型的数组table,初始为null
1）创建对象时，将加载因子loadFactor初始化为0.75,其他成员保持默认值
2）添加元素时，相当于putVal方法,需要先将元素的key哈希值获取出来，并且运算得出在数组中存放索引。
如果该索引处没有其他元素，则可以直接存放
如果该索引处有其他元素，则需要先判断是否相等，
    	如果相等，则覆盖
   	如果不相等，则继续判断，是否为树结构或链表结构，根据不同结构进行不同处理
3）如果需要扩容，则进行对应的扩容。
    	如果第一次添加，则扩容table的capacity为16，临界值threshold为12.
    	如果其他次扩容，则扩容table的capacity为2倍，临界值threshold为2倍.
4）当链表中节点数>=7 && capacity>=64 则将链表变成树结构
jdk7和jdk8的对比：
	结构	table数据类型	初始容量
jdk7	数组+链表	Entry	16
jdk8	数组+链表+红黑数	Node	0
jdk7中创建对象时，则初始化table容量为16（饿汉式）
jdk8中创建对象时，并没有初始化，而是第一次添加元素初始化table容量为16（懒汉式）

-- 10. java 自带线程池
1）newCachedThreadPool
创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。这种类型的线程池特点是：
工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。
如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。
在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。
2）newFixedThreadPool
创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。
3）newSingleThreadExecutor
创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。
4）newScheduleThreadPool
创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。延迟3秒执行。
```
